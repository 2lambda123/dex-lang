<!DOCTYPE HTML>
<html><head><link rel="stylesheet" href="style.css" type="text/css"><meta charset="UTF-8"></head><body><div id="main-output"><div class="cell"><div class="prose-block"><h1>Introduction to the Dex language</h1>
</div></div><div class="cell"><div class="prose-block"><p>Dex is a functional, statically typed language for array processing.
Here we introduce the language in a tutorial format. We assume
reading familiarity with functional programming in the Haskell/ML style
and numerical programming in the NumPy/MATLAB style.
This is a literate program with outputs generated mechanically.
You can follow along in the REPL, <code>dex repl</code>,
or, on Linux, in the live notebook: <code>dex web examples/tutorial.dx</code>.
See the README for installation instructions.</p>
</div></div><div class="cell"><div class="prose-block"><h2>Expression syntax</h2>
</div></div><div class="cell"><div class="prose-block"><p>We can evaluate and print expressions with <code>:p</code></p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> (1<span class="symbol">.</span> <span class="symbol">+</span> 2<span class="symbol">.</span>) <span class="symbol">*</span> 3<span class="symbol">.</span>
</div><div class="result-block">9.0</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We can write let bindings as <code>x = &lt;expr&gt;; &lt;expr&gt;</code>. Bindings can be separated
with a line break or a semicolon. Cosmetic line breaks can be escaped with <code>..</code></p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> x <span class="symbol">=</span> 1<span class="symbol">.</span>                <span class="comment">-- let binding
</span>   y <span class="symbol">=</span> (z <span class="symbol">=</span> 2<span class="symbol">.</span><span class="symbol">;</span> z <span class="symbol">+</span> 1<span class="symbol">.</span>)  <span class="comment">-- let binding of a nested let expression
</span>   <span class="symbol">.</span><span class="symbol">.</span>                    <span class="comment">-- escaped cosmetic line break
</span>   x <span class="symbol">+</span> y                 <span class="comment">-- body of let expression
</span></div><div class="result-block">4.0</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We also have lambda, tuple construction and (tuple) pattern-matching (destructuring):</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> (x, y) <span class="symbol">=</span> (1<span class="symbol">.</span>, 2<span class="symbol">.</span>)     <span class="comment">-- let binding (with pattern-matching), tuple construction
</span>   f <span class="symbol">=</span> <span class="keyword">lam</span> z<span class="symbol">.</span> x <span class="symbol">+</span> z <span class="symbol">*</span> y  <span class="comment">-- let binding of a lambda function
</span>   f 1<span class="symbol">.</span> <span class="symbol">+</span> f 2<span class="symbol">.</span>           <span class="comment">-- body of let expression
</span></div><div class="result-block">8.0</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We use white space for function application (we write <code>f x y</code> instead of <code>f(x, y)</code>).
To see how subexpressions are grouped, it can be helpful to pretty-print the
internal AST using <code>:parse</code>. For example, we see that function application
associates to the left and binds more tightly than infix operators.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f 1 2 3
</div><div class="result-block">(((f 1) 2) 3)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f 1 <span class="symbol">+</span> g 2
</div><div class="result-block">(%fadd((f 1), (g 2)))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>To reduce parentheses, we sometimes use <code>$</code> for function application. <code>$</code> binds
very loosely:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f <span class="symbol">$</span> x <span class="symbol">+</span> y
</div><div class="result-block">(f (%fadd(x, y)))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f (x <span class="symbol">+</span> y)
</div><div class="result-block">(f (%fadd(x, y)))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We can combine a let binding with a lambda expression, writing <code>f = lam x. &lt;expr&gt;</code>
as <code>f x = &lt;expr&gt;</code>. This is just syntactic sugar. These three expression all parse
to exactly the same thing:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f x y <span class="symbol">=</span> 1<span class="symbol">;</span> f 2 3
</div><div class="result-block">(f = (lam x . (lam y . 1));
((f 2) 3))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f <span class="symbol">=</span> <span class="keyword">lam</span> x y<span class="symbol">.</span> 1<span class="symbol">;</span> f 2 3
</div><div class="result-block">(f = (lam x . (lam y . 1));
((f 2) 3))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:parse</span> f <span class="symbol">=</span> <span class="keyword">lam</span> x<span class="symbol">.</span> <span class="keyword">lam</span> y<span class="symbol">.</span> 1<span class="symbol">;</span> f 2 3
</div><div class="result-block">(f = (lam x . (lam y . 1));
((f 2) 3))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><h2>Types</h2>
</div></div><div class="cell"><div class="prose-block"><p>Why did we write <code>1. + 2.</code> instead of just <code>1 + 2</code>? Let's try that:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> 1 <span class="symbol">+</span> 2
</div><div class="err-block">Type error:
Expected: Real
  Actual: Int
In: 1

:p 1 + 2
   ^^
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>The problem is that <code>1</code> is an integer whereas <code>+</code> operates on reals. (Note that
Haskell overloads <code>+</code> and literals using typeclasses. We could do the same,
but we're keeping it simple for now.) We can query the <em>type</em> of an
expression with <code>:t</code>.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> 1
</div><div class="result-block">Int</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> 1<span class="symbol">.</span>
</div><div class="result-block">Real</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> <span class="keyword">lam</span> x y<span class="symbol">.</span> x <span class="symbol">+</span> y
</div><div class="result-block">(Real -&gt; (Real -&gt; Real))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>The type system is completely static. As a consequence, type errors appear at a
function's call site rather than in its implementation.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> f x <span class="symbol">=</span> x <span class="symbol">+</span> x
   f 1
</div><div class="err-block">Type error:
Expected: Real
  Actual: Int
In: 1

   f 1
     ^
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>The expressions we've seen so far have been <em>implicitly</em> typed. There have
been no type annotations at all. The Dex compiler fills in the types using
very standard Hindley-Milner-style type inference. The result of this process,
is an <em>explicitly</em> typed IR, similar to System F, in which all binders are
annotated. We can look at the explicitly typed IR with <code>:typed</code>:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:typed</span> f x <span class="symbol">=</span> x <span class="symbol">*</span> x
       z <span class="symbol">=</span> 2<span class="symbol">.</span>0
       f z
</div><div class="result-block">(f::(Real -&gt; Real) = (lam x::Real . (%fmul(x, x)));
(z::Real = 2.0;
(f z)))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We can also add some explicit annotations if we like. Type inference then
becomes type checking.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:typed</span> f <span class="symbol">::</span> <span class="type-name">Real</span> <span class="symbol">-</span><span class="symbol">&gt;</span> <span class="type-name">Real</span>
       f x<span class="symbol">::</span><span class="type-name">Real</span> <span class="symbol">=</span> x <span class="symbol">*</span> x
       z<span class="symbol">::</span><span class="type-name">Real</span> <span class="symbol">=</span> 2<span class="symbol">.</span>0
       f z
</div><div class="result-block">(f::(Real -&gt; Real) = (lam x::Real . (%fmul(x, x)));
(z::Real = 2.0;
(f z)))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><h2>Polymorphism and let generalization</h2>
</div></div><div class="cell"><div class="prose-block"><p>Unusually for Hindley-Milner-style languages, user-supplied type annotation are
mandatory for let-bound <em>polymorphic</em> expressions. That is, we don't do let
generalization. For example, although we can write this:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:typed</span> (<span class="keyword">lam</span> x<span class="symbol">.</span> x) 1
</div><div class="result-block">((lam x::Int . x) 1)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>It's an error to write this:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:typed</span> id x <span class="symbol">=</span> x
       id 1
</div><div class="err-block">Type error:Ambiguous type variables: [?_3]

(id::(?_3 -&gt; ?_3), (lam x::?_3 . x))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Instead, we have to give the type explicitly:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:typed</span> id <span class="symbol">::</span> a <span class="symbol">-</span><span class="symbol">&gt;</span> a
       id x <span class="symbol">=</span> x
       <span class="symbol">.</span><span class="symbol">.</span>
       id 1
</div><div class="result-block">(id :: [a::T]. A a. (a -&gt; a)
id = (lam x::a . x);
(id @Int 1))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We <em>do</em> generalize when evaluating <code>:t</code>, so we can still ask what the
annotation needs to be:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> (<span class="keyword">lam</span> x<span class="symbol">.</span> x)
</div><div class="result-block">A a. (a -&gt; a)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>The motivation for this choice is a bit subtle. It's related to the reasons for
Haskell's (&quot;dreaded&quot;) monomorphism restriction: automatic let generalization can
lead to surprising runtime work duplication in the presence of polymorphism
that's not purely parametric. We'll say more about it later, when we discuss
index sets as types.</p>
</div></div><div class="cell"><div class="prose-block"><p>In the explicitly typed IR, polymorphism is represented by functions which
take types as arguments. Explicit types are supplied at call sites, as in
<code>id @Int 1</code> above. This type application is available (but optional) in the
source language too.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> id <span class="symbol">::</span> a <span class="symbol">-</span><span class="symbol">&gt;</span> a
   id x <span class="symbol">=</span> x
   id <span class="symbol">@</span><span class="type-name">Int</span> 1
</div><div class="result-block">1</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Generally, a design goal has been to make sure that all
well-typed terms in the explicitly typed IR can be written in the source
langauge too.</p>
</div></div><div class="cell"><div class="prose-block"><h2>Tables (arrays)</h2>
</div></div><div class="cell"><div class="prose-block"><p>The central data structure in Dex is the &quot;table&quot;. We could also
call it an &quot;vector&quot; or &quot;array&quot; and we'll use these terms interchangeably. A
table is a mapping from indices to elements. We can build one like this:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> [10,20,30]
</div><div class="result-block">(3=&gt;Int)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Notice its type, <code>(3=&gt;Int)</code>. Here <code>3</code> is a <em>type</em> representing the index set
<code>{0, 1, 2}</code>. The <code>=&gt;</code> arrow is the type constructor for table types. A table
<code>a=&gt;b</code> is a mapping from the index set <code>a</code> to the element type <code>b</code>. Our
particular table, <code>[10,20,30]</code>, maps <code>0</code> to <code>10</code>, <code>1</code> to <code>20</code> and <code>2</code> to <code>30</code>.</p>
</div></div><div class="cell"><div class="prose-block"><p>Index set types are quite constrainted, as we'll see later, but elements can be
any type, including tables. We can construct a two-dimensional table as a table
of tables:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> [[10,20,30],[100,200,300]]
</div><div class="result-block">(2=&gt;(3=&gt;Int))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Notice rectangularity is enforced by the type system. The elements of the
outer table all have the same type <code>3=&gt;Int</code> and therefore the same size. We'll
get a type error if we try to construct a non-rectangular two-dimensional table:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> [[10,20,30],[100]]
</div><div class="err-block">Type error:
Expected: (3=&gt;Int)
  Actual: (1=&gt;Int)
In: [100]

:t [[10,20,30],[100]]
               ^^^^^
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>This has an important consequence for the implementation: the elements of a
table all have the same size, and we can use an efficient unboxed runtime
representation (i.e. flat buffers and strided indices). Later, we'll see how to
represent ragged tables, with irregularly sized elements using existential
types, with corresponding run-time cost.</p>
</div></div><div class="cell"><div class="prose-block"><p>What can we do with a table? Surely we can index into it. In Dex, we use <code>.</code>
for indexing, so we might try to index in to a table like this:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> i <span class="symbol">=</span> 0
   xs <span class="symbol">=</span> [1,2,3]
   xs<span class="symbol">.</span>i
</div><div class="err-block">Type error:
Expected: 3
  Actual: Int
In: i

   xs.i
      ^
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Unfortunately, it's a type error. <code>i</code> is an integer, but we need an index of
type <code>3</code> (the index set <code>{0,1,2}</code>). The error might be surprising because we
know <code>i=0</code> in this case, but that's only true <em>dynamically</em> and the static type
system doesn't know about that. If we're willing to put up with runtime errors
we can cast the integer to the required index set.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> i <span class="symbol">=</span> 0
   xs <span class="symbol">=</span> [1,2,3]
   xs<span class="symbol">.</span>(asidx i)
</div><div class="result-block">1</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>But we're better off using indices of the right type to begin with. Where
would such an index come from? The main means of introducing an index is using
Dex's <code>for</code> construct:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> xs <span class="symbol">=</span> [1<span class="symbol">.</span>, 2<span class="symbol">.</span>, 3<span class="symbol">.</span>]
   ys <span class="symbol">=</span> <span class="keyword">for</span> i<span class="symbol">::</span>3 <span class="symbol">.</span> xs<span class="symbol">.</span>i <span class="symbol">*</span> xs<span class="symbol">.</span>i
   ys
</div><div class="result-block">[1.0, 4.0, 9.0]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p><code>for</code> is to tables as <code>lam</code> is to functions. It builds a new table whose
elements are the result of evaluating its body at each index <code>i</code> in the given
index set. Like <code>lam</code>, the type annotation (<code>::3</code>) is optional and can be
inferred. Also like <code>lam</code>, we can combine the let binding with the <code>for</code> expression
in a way that looks like mathematical index notation. Type inference gives us
the same thing as if we'd annotated the binders manually.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:typed</span> xs <span class="symbol">=</span> [1<span class="symbol">.</span>, 2<span class="symbol">.</span>, 3<span class="symbol">.</span>]
       ys<span class="symbol">.</span>i <span class="symbol">=</span> xs<span class="symbol">.</span>i <span class="symbol">*</span> xs<span class="symbol">.</span>i
       ys
</div><div class="result-block">(xs::(3=&gt;Real) = [1.0, 2.0, 3.0];
(ys::(3=&gt;Real) = (for  i::3 .
    (%fmul(xs.i, xs.i)));
ys))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Index set types interact nicely with polymorphism. The language of types, with
type variables, is a very natural way to express shape constraints.
For example, adding two vectors of the same size:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> addVec <span class="symbol">::</span> n<span class="symbol">=</span><span class="symbol">&gt;</span><span class="type-name">Real</span> <span class="symbol">-</span><span class="symbol">&gt;</span> n<span class="symbol">=</span><span class="symbol">&gt;</span><span class="type-name">Real</span> <span class="symbol">-</span><span class="symbol">&gt;</span> n<span class="symbol">=</span><span class="symbol">&gt;</span><span class="type-name">Real</span>
   addVec x y <span class="symbol">=</span> <span class="keyword">for</span> i<span class="symbol">.</span> x<span class="symbol">.</span>i <span class="symbol">+</span> y<span class="symbol">.</span>i
   <span class="symbol">.</span><span class="symbol">.</span>
   addVec [1<span class="symbol">.</span>0, 2<span class="symbol">.</span>0] [0<span class="symbol">.</span>1, 0<span class="symbol">.</span>2]
</div><div class="result-block">[1.1, 2.2]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Transposing an array</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> transpose <span class="symbol">::</span> n<span class="symbol">=</span><span class="symbol">&gt;</span>m<span class="symbol">=</span><span class="symbol">&gt;</span>a <span class="symbol">-</span><span class="symbol">&gt;</span> m<span class="symbol">=</span><span class="symbol">&gt;</span>n<span class="symbol">=</span><span class="symbol">&gt;</span>a
   transpose x <span class="symbol">=</span> <span class="keyword">for</span> i j<span class="symbol">.</span> x<span class="symbol">.</span>j<span class="symbol">.</span>i
   <span class="symbol">.</span><span class="symbol">.</span>
   transpose [[1,2,3],[10,20,30]]
</div><div class="result-block">[[1, 10], [2, 20], [3, 30]]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Extracting the diagonal of a square array</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> diag <span class="symbol">::</span> n<span class="symbol">=</span><span class="symbol">&gt;</span>n<span class="symbol">=</span><span class="symbol">&gt;</span>a <span class="symbol">-</span><span class="symbol">&gt;</span> n<span class="symbol">=</span><span class="symbol">&gt;</span>a
   diag x <span class="symbol">=</span> <span class="keyword">for</span> i<span class="symbol">.</span> x<span class="symbol">.</span>i<span class="symbol">.</span>i
   <span class="symbol">.</span><span class="symbol">.</span>
   diag [[1,2],[10,20]]
</div><div class="result-block">[1, 20]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><h2>TODO:</h2>
<ul>
<li>table/function contrast (cheap to create, expensive to apply and vice versa)</li>
<li>structured index sets like pairs</li>
<li>visible type application</li>
<li>existentials, packing/unpacking</li>
<li>input and output</li>
<li>compiler internals -- normalized IR, imperative IR, LLVM</li>
<li>currying tables</li>
<li>mention prelude</li>
<li>splittable PRNG</li>
<li>automatic differentiation</li>
<li>more syntax</li>
<li>scan, fold</li>
</ul>
</div></div></div></body></html>


