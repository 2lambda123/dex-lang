'# Molecular Dynamics in Dex

import plot

'This is more-or-less a port of Jax MD into Dex to see how molecular dynamics looks in
Dex. For now, the structure of the two implementations is pretty close. However, details
look different and the evolution will depend on what is or is not ergonomic in dex vs jax.

'## Math

def truncate (x: Float): Float =
  case x < 0.0 of
    True -> -floor(-x)
    False -> floor x

-- A mod that matches np.mod and python mod.
def pmod (x: Float) (y: Float): Float =
  x - floor(x / y) * y

-- A mod that matches np.fmod and c fmod.
def fmod (x: Float) (y: Float): Float =
  x - truncate (x / y) * y

def Vec (dim:Type) [Ix dim] : Type = dim=>Float

def sq_norm {dim} (r: Vec dim) : Float =
  sum $ for i. r.i * r.i

def norm {dim} (r: Vec dim) : Float =
  sqrt $ sq_norm r

'## Useful Quantities

def box_size_at_number_density (particle_count: Int) (density: Float) (dim: Int) : Float =
  pow ((i_to_f particle_count) / density) (1.0 / (i_to_f dim))

'## Spaces

def Displacement (dim:Type) : Type = Vec dim -> Vec dim -> Vec dim
def Shift        (dim:Type) : Type = Vec dim -> Vec dim -> Vec dim

free_displacement: ((dim:Type) ?-> Displacement dim) = \r_1 r_2. r_1 - r_2
free_shift: ((dim:Type) ?-> Shift dim) = \r dr. r + dr

def periodic_wrap {dim} (box: Float) (dr: dim=>Float) : (dim=>Float) =
  for i. (pmod (dr.i + box / 2.0) box) - box / 2.0

periodic_displacement: ((dim:Type) ?-> Float -> Displacement dim) =
  \box r_1 r_2. periodic_wrap box (r_1 - r_2)
periodic_shift:        ((dim:Type) ?-> Float -> Shift dim)        =
  \box r dr. for i. pmod (r.i + dr.i) box

'## Energy Functions

def Energy (n: Type) (dim: Type) : Type = (n=>Vec dim) -> Float

def soft_sphere (ε: Float) (α: Float) (σ: Float) (r: Float) : Float =
  case r < σ of
    True  -> ε / α * pow (1 - r / σ) α
    False -> 0.0

harmonic_soft_sphere = \sigma r. soft_sphere 1.0 2.0 sigma r

def pair_energy {dim n}
  (energy: Float -> Float)
  (displacement: Displacement dim)
  (r: n=>Vec dim)
  : Float =
  sum for (i, j).
    case (ordinal i) < (ordinal j) of
      True  -> energy $ norm $ displacement r.i r.j
      False -> 0.0

'## Minimization Functions

data FireDescentState n:Type dim:Type [Ix n, Ix dim] = MkFireDescentState {
     R:     (n=>Vec dim) &
     V:     (n=>Vec dim) &
     F:     (n=>Vec dim) &
     dt:    Float        &
     alpha: Float        &
     n_pos: Int
}

def get_position {dim n} (state: FireDescentState n dim) : (n=>Vec dim) =
  (MkFireDescentState {R, V, F, dt, alpha, n_pos}) = state
  R

def fire_descent_init {dim n}
  (dt: Float)
  (alpha: Float)
  (energy: Energy n dim)
  (r: n=>Vec dim)
  : FireDescentState n dim =
  force = \rp. -(grad energy) rp
  V = for i:n j:dim. 0.0
  F = force r
  n_pos: Int = 0
  MkFireDescentState {R=r, V, F, dt, alpha, n_pos}

def fire_descent_step {dim n}
  (shift: Shift dim)
  (energy: Energy n dim)
  (state: FireDescentState n dim)
  : FireDescentState n dim =
  -- Constants that parameterize the FIRE algorithm.
  -- TODO: Thread these constants through somehow.
  -- dougalm@ is there a canonical way to do this?
  dt_start = 0.1
  dt_max = 0.4
  n_min = 5
  f_inc = 1.1
  f_dec = 0.5
  f_alpha = 0.99
  alpha_start = 0.1

  ε = 0.000000001

  force = \r. -(grad energy) r

  -- FIRE algorithm.
  (MkFireDescentState {R, V, F, dt, alpha, n_pos}) = state

  -- Do a Velocity-Verlet step.
  R = for i. shift R.i (V.i *. dt + F.i *. pow dt 2)
  F_old = F
  F = force R
  V = V + dt * 0.5 .* (F_old + F)

  -- Rescale the velocity.
  F_norm = sqrt $ sum for (i, j). pow F.i.j 2
  V_norm = sqrt $ sum for (i, j). pow V.i.j 2

  V = V + alpha .* (F *. V_norm / (F_norm + ε) - V)

  -- Check whether the force is aligned with the velocity.
  FdotV = sum for (i, j). F.i.j * V.i.j

  -- Decide whether to increase the speed of the simulation or reduce it.
  (n_pos, dt, alpha) = if FdotV >= 0.0
    then
      dt' = if n_pos >= n_min then (min (dt * f_inc) dt_max) else dt
      alpha' = if n_pos >= n_min then (alpha * f_alpha) else alpha
      (n_pos + 1, dt', alpha')
    else (0, dt * f_dec, alpha_start)
  V = if FdotV >= 0.0 then V else zero

  MkFireDescentState { R, V, F, dt, alpha, n_pos }

'## Drawing

import png
import diagram

TwoDimensions = Fin 2

def draw_system {n} (r: n=>Vec TwoDimensions) : Diagram =
  disks = concat_diagrams for i.
    circle 0.5 |> move_xy (r.i.(0 @ TwoDimensions), r.i.(1 @ TwoDimensions))
  disks

'## Example
Initialize a system randomly.

N = 5000
d = 2
L = box_size_at_number_density (n_to_i N) 1.2 (n_to_i d)
L

R = rand_mat N d (\k. L * rand k) (new_key 0)

'Define energy and force function.

def energy {n d} (pos: n=>d=>Float) : Float
  = pair_energy (harmonic_soft_sphere 1.0) (periodic_displacement L) pos

:t energy R

energy R

force: (n:Type) ?-> (dim:Type) ?-> (n=>Vec dim) -> (n=>Vec dim) = \r. -(grad energy) r

:t force R

forces = force R

'Run 100 steps of minimization.

state = fire_descent_init 0.1 0.1 energy R

energy R
energy $ get_position $ fire_descent_step free_shift energy state

%time
(state', energies) = scan state \i:(Fin 100) s.
  s' = fire_descent_step (periodic_shift L) energy s
  (s', energy $ get_position s')

%time
:html show_plot $ y_plot energies

%time
:html render_svg (draw_system (get_position state')) ((0.0, 0.0), (L, L))

'## Neighbors optimization

'The above `pair_energy` function will compute the influence of every atom on
every other atom, regardless of how far apart they are.

'To simulate more efficiently, we'd like to approximate the pairwise
energy with an energy that only includes contributions from atoms that
are close enough to each other that we wish not to neglect them.

'This is a two-step operation:
- Break the simulation volume into a grid of cells, and do a linear
  pass over the atoms to group them by which cell each is in.
- Traverse every pair of adjacent cells and compute energy terms for
  every pair of atoms only in those cells, and no others.

'### Bounded lists

'We start with an abstraction of an incrementally growable list.  To
get O(1) insertion at the end, we (currently) have to give an upper
bound for the list's size.

-- TODO Can we encapsulate this BoundedList type as a `data` and still
-- define in-place mutation operations on it?
def BoundedList n [Ix n] a = (n & (n => a))

def unsafe_next_index {n} [Ix n] (ix:n) : n =
  unsafe_from_ordinal n $ ordinal ix + 1

-- TODO This is another place where an `unsafe_empty_init` function
-- would be useful.
def empty_bounded_list {n a} [Ix n] (dummy_val: a) : BoundedList n a =
  (unsafe_from_ordinal _ 0, for _. dummy_val)

-- The point of a `BoundedList` is O(1) push by in-place mutation
def bd_push {h n a} [Ix n] (lst_ref: Ref h (BoundedList n a)) (x: a) : {State h} Unit =
  sz_ref = fst_ref lst_ref
  sz = get sz_ref
  buf_ref = snd_ref lst_ref
  if ordinal sz < size n
    then
      buf_ref!sz := x
      sz_ref := unsafe_next_index sz
    else
      todo -- throw ()

-- Once we're done pushing, we can compact a `BoundedList` into a standard `List`.
def as_list {n a} (lst: BoundedList n a) : List a =
  (lim, buf) = lst
  n_result = ordinal lim
  AsList _ $ view i:(Fin n_result). buf.(unsafe_from_ordinal _ $ ordinal i)

'### Cell list

'We define a single index for the whole grid.

def GridIx dim grid_size [Ix dim] = dim => (Fin grid_size)

'A cell list is now just a `BoundedList` of the (indices of) the atoms
that appear in each cell in the grid.

def CellTable dim grid_size bucket_size atom_ix [Ix dim] =
  GridIx dim grid_size => BoundedList (Fin bucket_size) atom_ix

def target_cell {dim grid_size}
  (cell_size: Float) (atom: Vec dim) : GridIx dim grid_size =
  for dim. from_ordinal _ $ f_to_n $ atom.dim / cell_size

def cell_table {dim atom_ix}
  [Ix atom_ix]
  grid_size
  bucket_size
  cell_size
  (atoms: atom_ix => Vec dim) : (CellTable dim grid_size bucket_size atom_ix) =
  -- catch do
    yield_state (for _. empty_bounded_list $ unsafe_from_ordinal _ 0) \ref.
      for ix.
        cell = target_cell cell_size atoms.ix
        bd_push ref!cell ix

'Let's test it out:

desired_cell_size = 1.0

cells_per_side = floor(L / desired_cell_size)

cell_size = L / cells_per_side

grid_size = unsafe_i_to_n $ f_to_i cells_per_side

bucket_size = 10

%time
tbl = cell_table grid_size bucket_size cell_size $ get_position state'

:t tbl

as_list tbl.(unsafe_from_ordinal _ 0)

'### Now let's compute pairs of neighbors from our cell list

cell_neighbors_2d = [[-1, -1], [-1, 0], [-1, 1], [0, -1],
                     [0, 0], [0, 1], [1, -1], [1, 0], [1, 1]]

:t cell_neighbors_2d

def torus_offset {n} (ix: (Fin n)) (offset: Int) : (Fin n) =
  unsafe_from_ordinal _ $ unsafe_i_to_n $
    mod (n_to_i (ordinal ix) + offset) (n_to_i n)

neighbor_list_size = 40000

%time
def neighbor_list {grid_size bucket_size atom_ix}
  neighbor_list_size
  (tbl: CellTable TwoDimensions grid_size bucket_size atom_ix)
  (atoms: atom_ix => Vec TwoDimensions)
  : BoundedList (Fin neighbor_list_size) (atom_ix & atom_ix) =
  -- catch do
    yield_state (empty_bounded_list $ (from_ordinal _ 0, from_ordinal _ 0)) \ref.
      for cell_ix : (GridIx TwoDimensions grid_size).
        for nb.
          displacement = cell_neighbors_2d.nb
          neighbor_ix = for dim. torus_offset cell_ix.dim displacement.dim
          (AsList sz_atoms_1 atoms_1) = as_list tbl.cell_ix
          for atom1_ix : (Fin sz_atoms_1).
            atom1 = atoms_1.atom1_ix
            (AsList sz_atoms_2 atoms_2) = as_list tbl.neighbor_ix
            for atom2_ix : (Fin sz_atoms_2).
              atom2 = atoms_2.atom2_ix
              dist = norm $ periodic_displacement L atoms.atom1 atoms.atom2
              if dist < 1 then
                num = get $ fst_ref ref
                bd_push ref (atom1, atom2)
            ()
          ()

%time
res = neighbor_list neighbor_list_size tbl $ get_position state'

(AsList k _) = as_list res
k

def pair_energy_nl {dim n}
  (energy: Float -> Float)
  (displacement: Displacement dim)
  (r: n=>Vec dim)
  (neighbors: List (n & n))
  : Float =
  (AsList k nbrs) = neighbors
  sum for i.
    a1ix, a2ix = nbrs.i
    case (ordinal a1ix) < (ordinal a2ix) of
      True  -> energy $ norm $ displacement r.a1ix r.a2ix
      False -> 0.0

def energy_nl {n d} (neighbors: List (n & n)) (pos: n=>d=>Float) : Float
  = pair_energy_nl (harmonic_soft_sphere 1.0) (periodic_displacement L) pos neighbors

energy_nl (as_list res) (get_position state')

energy (get_position state')


def just_neighbor_list {n} (atoms:n=>(Fin 2)=>Float) : (List (n & n)) =
  tbl = cell_table grid_size bucket_size cell_size atoms
  res = neighbor_list neighbor_list_size tbl atoms
  as_list res

%time
state_nl = fire_descent_init 0.1 0.1 (energy_nl $ just_neighbor_list R) R

energy R
energy $ get_position $ fire_descent_step free_shift energy state

%time
(state_nl', energies_nl) = scan state \i:(Fin 100) s.
  nbrs = just_neighbor_list $ get_position s
  s' = fire_descent_step (periodic_shift L) (energy_nl nbrs) s
  (s', (energy_nl nbrs) $ get_position s')

%time
:html show_plot $ y_plot energies_nl

%time
:html render_svg (draw_system (get_position state_nl')) ((0.0, 0.0), (L, L))

L
